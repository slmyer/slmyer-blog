---
title: 'http'
author: 'slmyer'
date: '2024/12/25 16:30:30'
tags: ['http', '缓存', 'options']
summary: 'HTTP 超文本传输协议，它是一个应用层协议，主要用于 Web 与服务器之间的通信，它是一个基于请求和响应的无状态协议。'
---

HTTP 超文本传输协议，它是一个应用层协议，主要用于 Web 与服务器之间的通信，它是一个基于请求和响应的无状态协议。

> 无状态指的是每个请求都是一个独立的上下文

## 报文

HTTP 报文分为请求报文与响应报文，其组成分为以下三个部分：

1. 起始行：
   1. 请求的 URL
   2. 请求的方法
   3. HTTP 版本号
   4. 状态码
   5. 原因短句
2. 头部字段：
   1. 通用头部
   2. 请求头部
   3. 响应头部
   4. 实体头部，描述主体的长度与内容的头部
   5. 自定义头部
3. 主体：
   1. 请求主体，表示发送的资源
   2. 响应主体，表示资源本身

## 方法

HTTP 定义了一组请求方法，表示要对资源执行的操作。

> 幂等，指的是如果同样的请求执行一次与多次，对服务器的预期影响都是相同的，就可以称这个 HTTP 方法是幂等的。

1. 常见的幂等方法：
   1. GET
   2. OPTIONS
2. 常见的非幂等方法：
   1. POST

### POST 与 GET 请求的区别

GET 用于请求资源数据，而 POST 用于向服务器提交数据（常见的场景表单提交），它们主要是以下几点不同：

1. 参数位置

GET 的参数一般都是放在 URL Query 上，但是由于浏览器的限制，参数的长度会受到限制（限制一般是 2048个字符），POST 的请求参数一般都是放在请求主体中，它的参数长度没有明确的限制；

2. 幂等性

GET 请求一般都是幂等的，POST 用于提交数据，更新数据一般都是不幂等的；

3. 缓存

GET 请求可以被缓存；

4. 安全性

由于 GET 请求的参数是放置在 URL 上是对外可见的，不适合传输一些敏感参数；

### 预检请求 OPTIONS

主要是用于检测服务器所支持的请求方法与请求头，options 方法是安全、无副作用的；预检请求的触发时机是，在跨站请求中，发起的请求是非简单请求时，在这类请求发起之前就会触发预检请求；

#### 同源策略

> 同源指的是同协议、同域名、同端口

同源策略是浏览器独有的一种安全机制，它限制了当前文档只能与同源的资源进行交互。我们可以通过 CORS（基于 HTTP 头）来允许跨源访问。

#### 简单请求

简单请求不会触发预检请求，它必须满足以下几点要求：

1. 请求方法是：`GET`、`POST`、`HEAD`
2. 请求头仅限于： `Accept`、`Accep-Language`、`Content-Language`、`Content-Type`、`DNT`、`If-Modified-Since`、`If-None-Match`、`Range`
3. Content-Type 限制：`application/x-www-form-urlencoded`、`multipart/form-data` 或 `text/plain`

当跨站请求发生时，发起的请求为非简单请求，这时候就会先发起预检请求，它一般会携带当次请求的方法与请求头标识，告诉服务器此次请求需要使用的方法与自定义头：

```http
Orign: xx
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type
```

而服务器则会响应相关的响应头，来告诉浏览器它支持的 origin、方法、自定义头、相关凭证、缓存时间：

> Access-Control-Max-Age 可以设置该预检请求缓存的时间长短单位为秒，在有效时间内，浏览器无需为同一请求发起预检请求，这个缓存时间如果超出浏览器限制，将不会生效（Chromium 76 之后上限 2 小时）

```http
Access-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
Access-Control-Allow-Credentials: true
```

## 缓存

HTTP 缓存由请求头与响应头的组合控制，在浏览器发起的 HTTP 请求时都会首先路由到浏览器缓存，检查是否存在可用于处理请求的有效缓存响应，如果有匹配，则从缓存中响应。浏览器中常见的缓存分成两种：

### 强缓存

强缓存的工作依赖于：

1. HTTP/1.0 通过 Expires 设置过期时间，这个时间通常是服务器时间会产生偏差
2. 通过 Cache-Control 来设置缓存的机制，常见的配置有：
   1. max-age 设置一个 TTL
   2. no-store 不缓存任何内容
   3. no-cache 请求资源时，仍需向服务器进行验证

如果在强缓存内容生效期间，浏览器会直接从缓存中获取内容，而不是发起请求。

### 协商缓存

协商缓存是指在强缓存失效之后，浏览器向服务器发起请求以验证资源是否更新，它的缓存依赖于：

1. Last-Modified：浏览器会发送一个带有 If-Modified-Since 请求头的请求，来询问服务器资源是否放生变动，如果没有变动，服务器会返回一个 304 Not Modified；
2. ETag：ETag 是资源的标识符，浏览器会发送一个 If-None-Match 头携带此 ETag，浏览器会比较两次的 ETag，如果相同也会返回一个 304 Not Modified；

如果两者同时存在，则 ETag 优先。

另外还有一种**启发式缓存**，HTTP 会尽可能地多缓存，即使没有给出明确的给出 Cache-Control，如果满足其他的条件，响应也会被存储和重用。

## 常见的状态码

| 状态码                            | 含义                                                                                                                         |
| --------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| 100 Continue                      | 表示客户端已经发送请求的部分信息，并且服务器已经收到这些信息，返回 `100 Continue` 用来告知客户端继续发送剩余部分。           |
| 200 OK                            | 表示请求已成功处理，并返回了请求的资源。                                                                                     |
| 201 Created                       | 表示请求成功，一般都在响应头附加 Location 指向具体的引用                                                                     |
| 202 Accepted                      | 表示请求已接收，但尚未处理                                                                                                   |
| 203 Non-Authoritative Information | 表示服务器成功处理了请求，但是返回的数据可能是第三方获取的部分数据                                                           |
| 204 No Content                    | 表示请求成功，但是没有内容返回                                                                                               |
| 205 Reset Content                 | 表示请求成功，服务器告知浏览器重置表单                                                                                       |
| 206 Partial Content               | 表示服务器成功的处理了部分内容的请求                                                                                         |
| 300 Multiple Choices              | 表示请求了一个实际指向多个资源 URL 时会返回这个状态码，会有一个附加的资源列表供客户端选择                                    |
| 301 Moved Permanently             | 表示永久重定向，资源已经被永久挪动到新位置，Location 指向新的 URL，下次请求时使用新的地址                                    |
| 302 Found                         | 表示请求临时重定向，返回了临时的 URL，与上面 301 不同的是，301 返回的 Location 会被自动更新应用，而 302 下次请求时还是老地址 |
| 303 See Other                     | 表示请求的资源位于其他的 URL，告知客户端应该使用新的 URL 来获取资源                                                          |
| 304 Not Modified                  | 表示资源未被修改，客户端可以继续使用缓存                                                                                     |
| 307 Temporary Redirect            | 与 302 类似，也是临时重定向，但是要求请求方法与原方法一致                                                                    |
| 308 Permanent Redirect            | 与 301 类似，也是永久重定向，301 常用于 GET，而 308 适用任何方法                                                             |
| 400 Bad Request                   | 表示请求无效，服务无法理解请求                                                                                               |
| 401 Unauthorized                  | 表示请求未认证，缺少身份凭证                                                                                                 |
| 403 Forbidden                     | 表示无权限，与 401 相比它是认证成功但是无权限                                                                                |
| 404 Not Found                     | 表示请求的资源不存在                                                                                                         |
| 405 Method Not Allowed            | 表示请求 URL 的方法不支持                                                                                                    |
| 406 Not Acceptable                | 表示客户端通过 Accept 指定了不被支持的响应内容格式                                                                           |
| 408 Request Timeout               | 表示请求超时                                                                                                                 |
| 409 Conflict                      | 表示请求的资源与客户端请求冲突                                                                                               |
| 410 Gone                          | 表示请求的资源已被永久删除，且没有重定向地址                                                                                 |
| 414 URI Too Long                  | 表示请求的 URL 长度超出处理限制                                                                                              |
| 415 Unsupported Media Type        | 表示服务器无法处理客户端发送的主体内容类型                                                                                   |
| 429 Too Many Requests             | 表示客户端请求的频率过高，限制请求                                                                                           |
| 500 Internal Server Error         | 表示服务器错误                                                                                                               |
| 501 Not Implemented               | 表示请求超出服务器处理的能力范围                                                                                             |
| 502 Bad Gateway                   | 表示服务器作为网关或者代理时，收到无效的响应                                                                                 |
| 503 Service Unavailable           | 表示服务器当前无法处理请求，但是将来可以，并返回了一个 Retry- After                                                          |
| 504 Gateway Timeout               | 表示作为网关，未能在规定时间内从上游服务器获取响应                                                                           |

## HTTP/1.x 与 2.0 的区别

HTTP1.x 使用文本格式，基于请求/响应的形式传输，在 HTTP/1.0 每个请求都需要单独的 TCP 连接，而在 HTTP/1.1 默认使用持久连接，允许一个 TCP 发送多个请求，但是请求的仍然是顺序处理的，后一个请求必须等待上个请求完成；

HTTP2.0 引入了二进帧的概念，它将所有的数据视为流，分割成小的二进制单元，称之为 帧，然后以二进制帧的格式进行传输，它定义了多种帧的类型：

1. DATA 帧，数据帧
2. HEADERS 帧，头部帧
3. PRIORITY 优先级帧
4. RST_STREAM 重制帧
5. WINDOW_UPDATE 流量控制帧，用于接收方发送给发送方协定发送窗口的大小
6. SETTINGS 设置帧

帧的结构组成：

1. 长度，表示帧的 payload 长度
2. 类型，表示帧的类型
3. 标志
4. 流标识，表示当前帧属于哪个流
5. payload 数据部分

通过二进制分帧的机制，它允许多个流发送自己的帧，避免了队头阻塞问题，同时帧还包含自己的优先级信息，可以优先处理。此外 HTTP2.0 还使用 HPACK 头部压缩算法对 HTTP 头部进行了压缩，提高了数据传输速率；

1. 多路复用
2. 优先级处理
3. 流量控制，接收方可以通过 SETTINGS 设置初始的发送窗口大小，如果未指定将使用默认的窗口大小（64KB），在传输过程中可以使用 WINDOW_UPDATE 去更新窗口大小；
4. 服务器推送

### HTTP/2.0 怎么保证数据的传输

- **流控制** 通过调整每个流的 **窗口大小** 来控制数据的流速，从而保证数据按顺序传输。
- **WINDOW_UPDATE 帧** 起到了流控制的作用，它允许接收方调整窗口大小，通知发送方是否继续发送数据。
- **没有 ACK 和 seq** 机制，但通过流控制的反馈机制，间接实现了类似于 TCP 中的确认机制。

## HTTPS

HTTPS 是 HTTP 的安全版本，相对于HTTP 使用明文传输，它是在 TCP 与 HTTP 层增加一了层安全套接层 TLS 对数据进行加解密，它使用对称加密与非对称加密的结合以及利用 CA 证书认证方式确保数据传输的安全性；HTTPS 默认使用 443 端口通信，而 HTTP 使用的端口是 80；

工作过程：

1. 首先客户端向服务端发起请求，请求建立连接，并发送客户端支持的加密算法与随机数
2. 服务器选择加密算法，同时发送其数字证书以及一个随机数，这个 CA 证书包含服务器的公钥与服务器信息
3. 客户端验证证书的有效性，如果有效，它会生成一个预主密钥，然后使用服务器返回的公钥对其加密，发送给服务器
4. 服务器在接收到这个预主密钥之后，会使用 CA 的私钥对数据进行解密，获取这个预主密钥；
5. 此时客户端与服务器都有彼此的随机数与预主密钥，这时候就会生成会话密钥，在后续场景都是使用这个密钥对数据进行加密解密；

参考 TLS 相关解释：

1. [维基百科](https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A#TLS_1.3)
2. [维基百科](https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A#TLS_1.3)
